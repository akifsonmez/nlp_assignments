from collections import defaultdict
from itertools import product
import numpy


class CYK:
    def __init__(self):

        # rule set stored here
        # example 'NP': ['Det Noun', 'Pronoun', 'NP PP']
        # that means that 'NP' can generate one of the 'Det Noun', 'Pronoun', 'NP PP'
        self.rule_set = defaultdict(list)

        # reverse rule set stored here
        # example 'Pronoun': ['NP']
        # that means that Pronoun can be generated by "NP"
        self.rule_set_reverse = defaultdict(list)

        # words stored here
        # it used for random sentence generation
        self.word_list = []

    def rules(self, folder_path):
        """It takes only one argument:  folder path and returns CFG rule set."""

        # create empty dicts
        rule_set = defaultdict(list)
        rule_set_reverse = defaultdict(list)
        word_list = []

        # read file and get CFG rules and words from that file
        with open(folder_path) as data:
            for line in data.readlines():

                # get rid of from comments and empty lines
                if line.startswith("#") or line == "\n":
                    continue

                # process the line
                line = line.rstrip("\n")
                rule = line.split("\t")
                left_part = rule[0].strip()
                right_part = rule[1].strip()

                # get rid of comment part of rule
                if "#" in right_part:
                    right_part = " ".join(right_part.split()[:6])

                # append rules to dicts
                rule_set[left_part].append(right_part)
                rule_set_reverse[right_part].append(left_part)

                # if right part of the rule lower than it is a word
                # add that word into word list
                if right_part.islower():
                    word_list.append(right_part)

        # set class attributes
        self.rule_set = rule_set
        self.rule_set_reverse = rule_set_reverse
        self.word_list = word_list

        # return rule set
        return rule_set

    def rand_sentence(self, output_file):
        """It takes name of the output file and returns generated sentences (Also they will be
        written to the output file) . """
        # produce 10 sentence with random words
        random_sentences = []
        for n in numpy.random.randint(3, 10, 10):
            # choose n random word from word list
            random_words = numpy.random.choice(self.word_list, n)

            # create a sentence with the chosen random words
            random_sentence = " ".join(random_words)

            # append generated random word into list
            random_sentences.append(random_sentence)

        # write generated sentences to given file
        with open(output_file, 'w') as output:
            for r_s in random_sentences:
                output.write('%s\n' % r_s)
        return random_sentences

    def CYKParser(self, sentence):
        """It takes a sentence and print whether this sentence is grammatically correct or not."""

        # In order to explain my algorithm lets say we try to find out if "i prefer it" is grammatically correct or not
        # so our sentence is "i prefer it"

        # get word list of given sentence
        words = sentence.split()
        # after that
        # words = [i, prefer, it]

        # get word length of given sentence
        n = len(words)
        # after that
        # n = 3

        # create nxn matrix for CYK algorithm
        cyk_matrix = numpy.empty([n, n], dtype=object)

        #  After that cyk_matrix
        # [[None None None]
        #  [None None None]
        #  [None None  None]]

        # first get possible non-terminals that can generate corresponding word(terminal)
        # and fill the CYK matrix
        for i, w in enumerate(words):
            non_terminals = self.__get_word_non_terminals(w)
            cyk_matrix[0, i] = non_terminals

        # after that cyk_matrix
        # [['Pronoun', 'NP'] ['Verb'] ['Pronoun', 'NP']]
        #  [None None None]
        #  [None None None]]
        # so that means that
        # "i" is both "Pronoun" and "NP"
        # "prefer" is "Verb"
        # "it" is both "Pronoun" and "NP"

        # for the filling rest of the cyk matrix
        for i, r in enumerate(cyk_matrix[1:, :], 1):
            for j, c in enumerate(r[:-i]):
                possible_non_terminal = []
                for k in range(i - 1, -1, -1):
                    # get first non-terminal list from matrix (that we calculated before)
                    pre_calculated_1 = cyk_matrix[k, j]

                    # get second non-terminal list from matrix (that we calculated before)
                    pre_calculated_2 = cyk_matrix[(i - (k + 1)), (j + (k + 1))]

                    # do cross product of the non-terminal lists and get every non-terminal that can generate any
                    # elements of the that cross product
                    t = self.__get_list_non_terminals(pre_calculated_1, pre_calculated_2)

                    # add them into a list
                    possible_non_terminal.extend(t)

                # fill the cyk matrix
                cyk_matrix[i, j] = list(set(possible_non_terminal))

        # after that cyk_matrix
        # [[['Pronoun', 'NP'] ['Verb'] ['Pronoun', 'NP']]
        #  [[] ['VP'] None]
        #  [list(['S']) None None]]
        # so as we can see we reached "S" so "i prefer it" grammatically correct

        # Control if we reached "S" if so print "Correct" else print "Not Correct"
        if "S" in cyk_matrix[n - 1, 0]:
            print("Correct")
        else:
            print("Not Correct")

    def __get_word_non_terminals(self, word):
        """It takes only one argument: a word(terminal) and returns list of non-terminal that can generate given word"""

        # get the non-terminal that can generate given word
        non_terminal_list = self.rule_set_reverse[word]

        # but there is a tricky part
        # for example "i" can be generated by "Pronoun" and also "Pronoun" can be generated by "NP"
        # so we have to check that as well
        for i in non_terminal_list:
            non_terminal_list.extend(self.rule_set_reverse[i])
        return non_terminal_list

    def __get_list_non_terminals(self, non_terminal_list1, non_terminal_list2):
        """It takes two list that contains some non-terminals. It makes cross product of given lists. And it controls if
        each element of the cross product can be generated by any non-terminal if so it adds them to a list and returns
        that list """

        non_terminal_list = []
        for i in product(non_terminal_list1, non_terminal_list2):
            non_terminal_list.extend(self.rule_set_reverse[" ".join(i)])
        return non_terminal_list


# create a CYK object
cyk = CYK()

# get the rules
cfg_rule_set = cyk.rules("cfg.gr")

# generate 10 sentence
rand_sentences = cyk.rand_sentence("output.txt")

# control whether random sentences are grammatically correct or not
for s in rand_sentences:
    cyk.CYKParser(s)

print("\nTESTING WITH MY SENTENCES")
cyk.CYKParser("a delicious mouse with the old sandwich want this beautiful president")
cyk.CYKParser("i prefer it")
cyk.CYKParser("i")
cyk.CYKParser("i prefer mouse")
cyk.CYKParser("i prefer a mouse")
cyk.CYKParser("i prefer a old mouse")
cyk.CYKParser("i prefer old mouse")
